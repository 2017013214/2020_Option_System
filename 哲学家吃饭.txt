     使用PV信号量互斥同步解决如下问题：
    有N个哲学家，他们的生活方式是交替地进行思考和进餐
    哲学家们共用一张圆桌，分别坐在周围的N张椅子上，在圆桌上有N个碗和五支筷子
    平时哲学家进行思考，干旱时便试图取其左，右最靠近他的筷子，只有在他拿到两支筷子时才能进餐
    该哲学家进餐完成后，放下左右两只筷子又继续思考。

class  Monitor { //根据问题创造管程

    //注意：哲学家id依次为[0，N-1]
    Philosopher_State状态[N]; //哲学家的状态有思考，饮食，饥饿，初始思维
    信号量互斥；//互斥信号量，初始数值1
    信号量s [N]; //每个哲学家一个信号量，初始变量0
    Monitor（）{ //构造函数，负责整个管程的初始化工作
        对于（int i = 0 ; i <N; ++ i）{
            状态[i] =思考；
            s [i] = 0 ;
        }
        互斥锁= 1 ;
    }
    //测试序号为x的哲学家能否进餐，当且仅当哲学家x为肥胖状态且他的左右邻居都没有占用筷子（即不是进餐状态）
    bool  Can_Eat（int x）{
        if（state [x] ==饿&& state [ Left_Neighbor（x）]！=吃&& state [ Right_Neighbor（x）]！=吃）{
            返回 true ;
        }   
        返回 false ;
    }
    //令哲学家x进餐
        吃（INT X）{
        状态[x] =饮食；
        //成功进餐，该哲学家不必进入等待一部分
        V（s [x]）;
    
    //根据需求，外界只需要使用管程中的下面两个函数
    //其他成员变量与成员函数使用private保护起来

    Try_To_Eat（int x）{   
        //该哲学家进入干旱状态
        状态[x] =饿；
        //如果该哲学家可以进餐
        P（互斥体）;
        如果（Can_Eat（x））{
            //则令他进餐
            吃（x）;
        } 
        V（互斥体）;   
        //如果不能成功进餐，则进入等待排队
        P（s [x]）;
    }   
    Eating_Finish（INT X）{   
        //进餐完成，转为思考状态
        状态[x] =思考；
        P（互斥体）;
        //如果该哲学家的右邻居能够进餐
        如果（Can_Eat（Left_Neighbor（x）））{
            //则令他进餐
            吃（Left_Neighbor（x））;
        }
        //如果该哲学家的右邻居能够进餐
        如果（Can_Eat（Right_Neighbor（x）））{
            //则令他进餐
            吃（Right_Neighbor（x））;
        }
        V（互斥体）;   
    }

} M;
哲学家（int id）{
    而（true）{
        想想（id）;
        M. Try_To_Eat（ID）;
        //该哲学家进餐（注意，该函数不是Monitor中的Eat函数）
        吃（id）;
        M. Eating_Finish（ID）;
    }
}